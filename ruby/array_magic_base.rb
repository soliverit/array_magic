class ArrayMagicBase
	attr_accessor :trainTestRatio, :nSamples, :reportSteps, :iterations, :maxError, :silent, :nInputs
	##
	# Generic NN properties
	##
	# Iterations/steps/generations or whatever (not generations but you get the point)
	DEFAULT_ITERATIONS		= 100
	# Number of samples in the test/train dataset. Generated by the model during .train
	DEFAULT_N_SAMPLES		= 1000
	# Train / Test split
	DEFAULT_TRAIN_TEST		= 0.5
	# How frequent should results
	DEFAULT_REPORT_STEPS	= 100
	# Maximum acceptaed error. Typically RMSE/MSE
	DEFAULT_MAX_ERROR		= 0.1
	# Number of nodes on the input layer
	DEFAULT_N_INPUTS		= 2
	def initialize 
		# Set stuff with class defaults
		@reportSteps	= DEFAULT_REPORT_STEPS	
		@nSamples		= DEFAULT_N_SAMPLES
		@trainTestRatio	= DEFAULT_TRAIN_TEST
		@iterations		= DEFAULT_ITERATIONS
		@maxError		= DEFAULT_MAX_ERROR
		@nInputs		= DEFAULT_N_INPUTS
		# Set misc defaults
		@silent			= false
	end
	##
	# Train the machine.
	#
	# This method is to ensure common tasks are performed
	# during prepartion, training and whatever might follow.
	#
	# The method currently ensures that training and if 
	# if necessary, test data, before training the machine.
	#
	##
	def train
		##
		# Never train twice.
		##
		return if @machine
		##
		# Abstract method that creates the training and if necessary,
		# test data. !Must be overridden!
		##
		prepareData
		##
		# Abstract method that does the actual training. !Must be overridden!
		##
		@machine = doTraining
	end
	##
	# Run a test using the @xData[:test], @yData[:test] samples.
	#
	# This method's a bit more informal. It's useful to have
	# access to the model's interior when testing. And, as with
	# everything else, consistent methods are always ideal.
	#
	##
	def test #Abstract
		raise "ArrayMagicBase:test hasn't been overridden"
	end
	##
	# Create training, and if necessary, test samples
	#
	# Each machine has its own data generation process. This method
	# is meant to create training/test samples, ideally stored 
	# in @xData{train:[], test:[]} and @yData{train: [], test:[]} but
	# you do you. As long as your doTraining method can access the 
	# samples, it's all good.
	##
	def prepareData #Abstract
		raise "ArrayMagicBase:prepareData hasn't been overridden"
	end
	##
	# Do the actual training.
	# 
	#
	# This method should use the training data and relevant and
	# properties (@maxError, @iterations,...) to train a model 
	# of any kind. Typically, this project will use neural networks
	# in the examples but nothing's stopping you from using any
	# other ML learner so long as you shape your training data
	# and predict method to meet the learner's requirements.
	#
	##
	def doTraining #Abstract
		raise "ArrayMagicBase:doTraining hasn't been overridden."
	end
	##
	# Make a prediction.
	#
	# A placeholder method for turning inputs into a prediction. By
	# default, the method is for "fast-ANN" with the "run" method. Other
	# models have alternative function names and single/multii outputs.
	##
	def predict inputs #Virtual
		@machine.run(inputs)
	end
end